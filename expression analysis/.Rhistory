de2tags
de2
head(de2)
?decideTestsDGE
ls
topTags(de_glm, n = 10)
top <- topTags(de.tgw, n=50)
ensembl=useMart("ensembl", dataset="mmusculus_gene_ensembl")
geneNames <- getBM("external_gene_name", filters = "ensembl_gene_id", values = rownames(top), ensembl)
top <- cbind(top, geneNames)
top <- topTags(de_glm, n=50)
ensembl=useMart("ensembl", dataset="mmusculus_gene_ensembl")
geneNames <- getBM("external_gene_name", filters = "ensembl_gene_id", values = rownames(top), ensembl)
top <- cbind(top, geneNames)
top
de_glm
class(d2)
d2$counts
rownames(top)
de2$counts[rownames(top), ]
de2$counts
d2$counts[rownames(top), ]
?mean
mewn(d2$counts[rownames(top), ])
mean(d2$counts[rownames(top), ])
rowMeans(d2$counts[rownames(top), ])
dim(rowMeans(d2$counts[rownames(top), ]))
lenght(rowMeans(d2$counts[rownames(top), ]))
length(rowMeans(d2$counts[rownames(top), ]))
dim(top)
means <- rowMeans(d2$counts[rownames(top), ])
top[1]
top[1,]
top <- cbind(top, means)
top[1,]
colnames(top)
colnames(top)[6]
colnames(d2)
colnames(d)
d[1,1]
d2[1,1]
colnames(top)[6] <- "Mean gene count"
apply(d2$counts,1,sd)
colnames(top)[last]
colnames(top)[end]
colnames(top)[]
colnames(top)
colnames(top)[7] <- "Gene count Std Dev"
sdevs <- apply(d2$counts,1,sd)
top <- cbind(top, stdevs)
colnames(top)[7] <- "Gene count Std Dev"
stdevs <- apply(d2$counts,1,sd)
top <- cbind(top, stdevs)
colnames(top)[7] <- "Gene count Std Dev"
stdevs
d2$counts
stdevs <- apply(d2$counts[rownames(top)], 1, sd)
stdevs <- apply(d2$counts[rownames(top), ], 1, sd)
top <- cbind(top, stdevs)
colnames(top)[7] <- "Gene count Std Dev"
top
colnames(top)[6] <- "Mean_count"
colnames(top)[7] <- "Count_Std_Dev"
top
colnames(top)[5] <- "Gene_Name"
top
kurtosis(d2$counts[rownames(top), ])
install.packages("PerformanceAnalytics")
library(performanceAnalytics) # for kertosis calculations
install.packages("PerformanceAnalytics")
install.packages("PerformanceAnalytics")
library(performanceAnalytics) # for kertosis calculations
library(PerformanceAnalytics) # for kertosis calculations
kertosis(d2$counts[rownames(top), ])
kurtosis(d2$counts[rownames(top), ])
kurtosises  <- kurtosis(d2$counts[rownames(top), ])
top <- cbind(top, kurtosises)
colnames(top)[7] <- "Count_Kurtosis"
top
top <- topTags(de_glm, n=50)
top
ensembl=useMart("ensembl", dataset="mmusculus_gene_ensembl")
geneNames <- getBM("external_gene_name", filters = "ensembl_gene_id", values = rownames(top), ensembl)
top <- cbind(top, geneNames)
colnames(top)[5] <- "Gene_Name"
top
means <- rowMeans(d2$counts[rownames(top), ])
top <- cbind(top, means)
colnames(top)[6] <- "Mean_count"
stdevs <- apply(d2$counts[rownames(top), ], 1, sd)
top <- cbind(top, stdevs)
colnames(top)[7] <- "Count_Std_Dev"
top
kurtosises  <- kurtosis(d2$counts[rownames(top), ])
cbind(top, kurtosises)
t(kurtosises)
cbind(top, t(kurtosises)
)
View(kurtosises)
rownames(top)
d2$counts[rownames(top), ]
?kurtosis
kurtosises  <- apply(d2$counts[rownames(top), ], 1, kurtosis)
kurtosises
cbind(top, kurtosises)
kurtosises  <- apply(d2$counts[rownames(top), ], 1, kurtosis)
top <- cbind(top, kurtosises)
colnames(top)[7] <- "Count_Kurtosis"
top
colnames(top)[7] <- "Count_Std_Dev"
colnames(top)[8] <- "Count_Kurtosis"
top
q()
q()
library(dplyr) # for subsetting data
library(R.utils) # for unzipping data
library(synapseClient) # to download data
library(edgeR) # for DE analysis
library(biomaRt) # for gene name lookups
library(ggplot2) # for better boxplots
library(reshape2) # for melt for ggplot
library(PerformanceAnalytics) # for kertosis calculations
## Get data and define groups
#Login to Synapse using credentials saved in .synapseConfig file
synapseLogin()
# get the transposed readcount file and covariates file from synapse
countFile <- synGet('syn3192634')
covariatesFile <- synGet('syn2875343') # the working dir copy
localCountFilePath <- getFileLocation(countFile)
if(!file.exists(sub('.gz', '', localCountFilePath))) {
gunzip(localCountFilePath)
}
localCountFilePath <- sub('.gz', '', localCountFilePath) #trim the .gz suffix
counts <- read.table(localCountFilePath, header = TRUE, stringsAsFactors = FALSE)
colnames(counts)[1] <- "LP_62_4"
# load covariates file to have handy
covariates <- read.table(getFileLocation(covariatesFile), header = TRUE, stringsAsFactors = FALSE)
# get JNPL3 subset of counts from counts file
JNPL3Counts <- dplyr::select(counts,
one_of(covariates[(covariates$Experiment == "MAPT_P301L"), ]$Mouse_ID))
# define groups
targets <- data.frame(Sample = covariates[(covariates$Experiment == "MAPT_P301L"), ]$Mouse_ID,
Genotype = covariates[(covariates$Experiment == "MAPT_P301L"), ]$Genotype,
Age = as.factor(covariates[(covariates$Experiment == "MAPT_P301L"), ]$Age_months))
group <- factor(paste(targets$Genotype, targets$Age, sep = "."))
JNPL3 <- (counts = JNPL3Counts, group = group)
JNPL3Counts
head(JNPL3Counts)
JNPL3 <- (counts = JNPL3Counts, group = group)
JNPL3 <- DGEList(counts = JNPL3Counts, group = group)
dim(JNPL3)
keep <- rowSums(cpm(JNPL3)>100) >= 2
d <- JNPL3[keep,]
dim(d)
#3133   24
d$samples$lib.size <- colSums(d$counts)
d <- calcNormFactors(d, method = "TMM")
plotMDS(d, method="bcv", col=as.numeric(d$samples$group))
legend("bottomleft", as.character(unique(d$samples$group)), col=1:3, pch=20)
design.mat <- model.matrix(~0 + targets$Genotype + targets$Genotype:targets$Age)
design.mat
colnames(design.mat)
targets
design.mat <- model.matrix(~0 + targets$Genotype + targets$Genotype:targets$Age)
colnames(design.mat)
factor(paste(targets$Age, targets$Genotype, sep=""))
testGroup <- factor(paste(targets$Age, targets$Genotype, sep=""))
testDesign.mat <- model.matrix(~0 + group)
testDesign.mat
design.mat
colnames(design.mat)
class(design.mat)
twoPlus <- c(rep(0, length(design.mat[1,])))
twoPlus
twoPlus <- c(rep(0, length(design.mat[,1])))
twoPlus
targets
twoPlus[16]
twoPlus[16] <- 1
twoPlus
twoPlus[17] <- 1
twoPlus[24] <- 1
q()
library(dplyr) # for subsetting data
library(R.utils) # for unzipping data
library(synapseClient) # to download data
library(edgeR) # for DE analysis
library(biomaRt) # for gene name lookups
library(ggplot2) # for better boxplots
library(reshape2) # for melt for ggplot
library(PerformanceAnalytics) # for kertosis calculations
## Get data and define groups
#Login to Synapse using credentials saved in .synapseConfig file
synapseLogin()
# get the transposed readcount file and covariates file from synapse
countFile <- synGet('syn3192634')
covariatesFile <- synGet('syn2875343') # the working dir copy
# unzip count file and load for processing
localCountFilePath <- getFileLocation(countFile)
if(!file.exists(sub('.gz', '', localCountFilePath))) {
gunzip(localCountFilePath)
}
localCountFilePath <- sub('.gz', '', localCountFilePath) #trim the .gz suffix
counts <- read.table(localCountFilePath, header = TRUE, stringsAsFactors = FALSE)
colnames(counts)[1] <- "LP_62_4"
covariates <- read.table(getFileLocation(covariatesFile), header = TRUE, stringsAsFactors = FALSE)
# get JNPL3 subset of counts from counts file
JNPL3Counts <- dplyr::select(counts,
one_of(covariates[(covariates$Experiment == "MAPT_P301L"), ]$Mouse_ID))
# define groups
targets <- data.frame(Sample = covariates[(covariates$Experiment == "MAPT_P301L"), ]$Mouse_ID,
Genotype = covariates[(covariates$Experiment == "MAPT_P301L"), ]$Genotype,
Age = as.factor(covariates[(covariates$Experiment == "MAPT_P301L"), ]$Age_months))
group <- factor(paste(targets$Genotype, targets$Age, sep = "."))
## Make DGEList object to start working on DE analysis
JNPL3 <- DGEList(counts = JNPL3Counts, group = group)
targets
group
dim(JNPL3)
keep <- rowSums(cpm(JNPL3)>100) >= 2
d <- JNPL3[keep,]
dim(d)
#3133   24
# reset library sizes after filtering
d$samples$lib.size <- colSums(d$counts)
# normalize the data using TMM
d <- calcNormFactors(d, method = "TMM")
plotMDS(d, method="bcv", col=as.numeric(d$samples$group))
legend("bottomleft", as.character(unique(d$samples$group)), col=1:3, pch=20)
group
class(group)
design.mat <- model.matrix(~0 + group)
design.mat
group
colnames(design.mat) <- levels(d$samples$group)
d2 <- estimateGLMCommonDisp(d,design.mat)
d2 <- estimateGLMTrendedDisp(d2,design.mat) #method = "power" also a possibility
d2 <- estimateGLMTagwiseDisp(d2, design.mat)
plotBCV(d2) # seems nice - blue line looks like it follows points...
fit <- glmFit(d2, design.mat)
de_glm  <- glmLRT(fit, contrast=c(-1,1)) # -1*JNPL3Minus 1*JNPL3Plus
design
design.mat
de_glm  <- glmLRT(fit, contrast=c(-1, 0, 0, 1 ,0, 0)) # -1*JNPL3Minus 1*JNPL3Plus
summary(decideTestsDGE(de_glm, p.value=0.01))
topTags(de_glm)
de_glm  <- glmLRT(fit, contrast="(+.2 + +.6 + +.12)/3 - (-.2 + -.6 + -.12)/3") # -1*JNPL3Minus 1*JNPL3Plus
?glmLRT
de_glm  <- glmLRT(fit, contrast=c(-1, -1, -1, 1, 1, 1)) # -1*JNPL3Minus 1*JNPL3Plus
summary(decideTestsDGE(de_glm, p.value=0.01))
topTags(de_glm)
setwd("~/Projects/UO1-AMP/working/expression analysis")
library(dplyr) # for subsetting data
library(R.utils) # for unzipping data
library(synapseClient) # to download data
library(edgeR) # for DE analysis
library(biomaRt) # for gene name lookups
library(ggplot2) # for better boxplots
library(reshape2) # for melt for ggplot
library(PerformanceAnalytics) # for kertosis calculations
## Get data and define groups
#Login to Synapse using credentials saved in .synapseConfig file
synapseLogin()
# get the transposed readcount file and covariates file from synapse
countFile <- synGet('syn3192634')
covariatesFile <- synGet('syn2875343') # the working dir copy
# unzip count file and load for processing
localCountFilePath <- getFileLocation(countFile)
if(!file.exists(sub('.gz', '', localCountFilePath))) {
gunzip(localCountFilePath)
}
localCountFilePath <- sub('.gz', '', localCountFilePath) #trim the .gz suffix
counts <- read.table(localCountFilePath, header = TRUE, stringsAsFactors = FALSE)
#PROBLEM: - an rTGMinus sample
#in count data, sample “LP62_4”
#in covariates, sample “LP_62_4”
# for now, change column name in counts - TODO: fix covariates file
colnames(counts)[1] <- "LP_62_4"
# load covariates file to have handy
covariates <- read.table(getFileLocation(covariatesFile), header = TRUE, stringsAsFactors = FALSE)
## define groups: JNPL3+ (transgenic), JNPL3- (WT), (ignore rTG+ rTG- for now)
# (there MUST be a cleaner way to do this)
# JNPL3+:
# 15 samples
JNPL3Plus <- dplyr::select(filter(covariates, Experiment == "MAPT_P301L" & Genotype == "+"), Mouse_ID)
# JNPL3-:
JNPL3Minus <- dplyr::select(filter(covariates, Experiment == "MAPT_P301L" & Genotype == "-"), Mouse_ID)
# 9 samples
JNPL3Plus <- as.character(JNPL3Plus$Mouse_ID)
JNPL3Minus <- as.character(JNPL3Minus$Mouse_ID)
JNPL3PlusCols <- is.element(as.character(colnames(counts)), JNPL3Plus)
JNPL3MinusCols <- is.element(as.character(colnames(counts)), JNPL3Minus)
groups <- c(rep(0, length(counts[1,])))
groups[JNPL3PlusCols] <- "JNPL3Plus"
groups[JNPL3MinusCols] <- "JNPL3Minus"
groups
JNPL3Samples <- c(JNPL3Plus, JNPL3Minus)
JNPL3Cols <- is.element(as.character(colnames(counts)), JNPL3Samples)
## Make DGEList object to start working on DE analysis
JNPL3 <- DGEList(counts = dplyr::select(counts, one_of(JNPL3Samples)),
group = groups[JNPL3Cols])
groups[JNPL3Cols]
d.full <- JNPL3 # keep the old one in case we mess up
dim(d.full)
#39179    24
keep <- rowSums(cpm(JNPL3)>100) >= 2
d <- JNPL3[keep,]
dim(d)
#3133   24
# reset library sizes after filtering
d$samples$lib.size <- colSums(d$counts)
# normalize the data using TMM
d <- calcNormFactors(d, method = "TMM")
plotMDS(d, method="bcv", col=as.numeric(d$samples$group))
legend("bottomleft", as.character(unique(d$samples$group)), col=1:3, pch=20)
design.mat <- model.matrix(~0 + d$samples$group)
design.mat
colnames(design.mat) <- levels(d$samples$group)
d2 <- estimateGLMCommonDisp(d,design.mat)
d2 <- estimateGLMTrendedDisp(d2,design.mat) #method = "power" also a possibility
# You can change method to "auto", "bin.spline", "power", "spline", "bin.loess".
# The default is "auto" which chooses "bin.spline" when > 200 tags and "power" otherwise.
d2 <- estimateGLMTagwiseDisp(d2, design.mat)
plotBCV(d2) # seems nice - blue line looks like it follows points...
design.mat
JNPL3Counts <- dplyr::select(counts,
one_of(covariates[(covariates$Experiment == "MAPT_P301L"), ]$Mouse_ID))
# define groups
targets <- data.frame(Sample = covariates[(covariates$Experiment == "MAPT_P301L"), ]$Mouse_ID,
Genotype = covariates[(covariates$Experiment == "MAPT_P301L"), ]$Genotype,
Age = as.factor(covariates[(covariates$Experiment == "MAPT_P301L"), ]$Age_months))
group <- factor(paste(targets$Genotype, targets$Age, sep = "."))
group
JNPL3 <- DGEList(counts = JNPL3Counts, group = group)
## filter data
# require minimum of 100 counts per million for at least 2 samples
dim(JNPL3)
#39179    24
keep <- rowSums(cpm(JNPL3)>100) >= 2
d <- JNPL3[keep,]
dim(d)
#3133   24
# reset library sizes after filtering
d$samples$lib.size <- colSums(d$counts)
# normalize the data using TMM
d <- calcNormFactors(d, method = "TMM")
plotMDS(d, method="bcv", col=as.numeric(d$samples$group))
legend("bottomleft", as.character(unique(d$samples$group)), col=1:3, pch=20)
design.mat <- model.matrix(~0 + group)
design.mat
colnames(design.mat) <- levels(d$samples$group)
d2 <- estimateGLMCommonDisp(d,design.mat)
d2 <- estimateGLMTrendedDisp(d2,design.mat) #method = "power" also a possibility
d2 <- estimateGLMTagwiseDisp(d2, design.mat)
plotBCV(d2) # seems nice - blue line looks like it follows points...
design.mat
de_glm  <- glmLRT(fit, contrast=c(-1, -1, -1, 1, 1, 1)) # -1*JNPL3Minus 1*JNPL3Plus
fit <- glmFit(d2, design.mat)
de_glm  <- glmLRT(fit, contrast=c(-1, -1, -1, 1, 1, 1)) # -1*JNPL3Minus 1*JNPL3Plus
summary(decideTestsDGE(de_glm, p.value=0.01))
#[,1]
#-1    1
#0  3132
#1     0
topTags(de_glm)
topTen <- rownames(topTags(de_glm, n = 10))
toPlot <- d[topTen] #10 rows, 24 columns
top <- topTags(de_glm, n=50)
# get gene names for x axis labels
ensembl=useMart("ensembl", dataset="mmusculus_gene_ensembl")
geneNames <- getBM(c("ensembl_gene_id", "external_gene_name"),
filters = "ensembl_gene_id",
values = rownames(top)[1:10],
ensembl)
# get label order right for plot
labels <- geneNames$external_gene_name[(order(match(geneNames$ensembl_gene_id, rownames(top)[1:10])))]
# munge to use with ggplot and plot
toPlot2 <- melt(test)
geom_boxplot(aes(fill = toPlot.samples.group)) +
## FINALLY, Build summary table with desired outputs (using the glmLRT results here)
ggplot(toPlot2, aes(factor(variable), value)) +
test  <- data.frame(toPlot$samples$group, t(toPlot$counts))
scale_x_discrete(labels = labels)
toPlot
toPlot2
test  <- data.frame(toPlot$samples$group, t(toPlot$counts))
toPlot2 <- melt(test)
ggplot(toPlot2, aes(factor(variable), value)) +
geom_boxplot(aes(fill = toPlot.samples.group)) +
scale_x_discrete(labels = labels)
covariates <- read.table(getFileLocation(covariatesFile), header = TRUE, stringsAsFactors = FALSE)
## define groups: JNPL3+ (transgenic), JNPL3- (WT), (ignore rTG+ rTG- for now)
# (there MUST be a cleaner way to do this)
# JNPL3+:
JNPL3Plus <- dplyr::select(filter(covariates, Experiment == "MAPT_P301L" & Genotype == "+"), Mouse_ID)
# 15 samples
# JNPL3-:
JNPL3Minus <- dplyr::select(filter(covariates, Experiment == "MAPT_P301L" & Genotype == "-"), Mouse_ID)
# 9 samples
JNPL3Plus <- as.character(JNPL3Plus$Mouse_ID)
JNPL3Minus <- as.character(JNPL3Minus$Mouse_ID)
JNPL3PlusCols <- is.element(as.character(colnames(counts)), JNPL3Plus)
JNPL3MinusCols <- is.element(as.character(colnames(counts)), JNPL3Minus)
groups <- c(rep(0, length(counts[1,])))
groups[JNPL3PlusCols] <- "JNPL3Plus"
groups[JNPL3MinusCols] <- "JNPL3Minus"
JNPL3Samples <- c(JNPL3Plus, JNPL3Minus)
JNPL3Cols <- is.element(as.character(colnames(counts)), JNPL3Samples)
## Make DGEList object to start working on DE analysis
JNPL3 <- DGEList(counts = dplyr::select(counts, one_of(JNPL3Samples)),
group = groups[JNPL3Cols])
## filter data
# require minimum of 100 counts per million for at least 2 samples
d.full <- JNPL3 # keep the old one in case we mess up
dim(d.full)
#39179    24
keep <- rowSums(cpm(JNPL3)>100) >= 2
d <- JNPL3[keep,]
dim(d)
#3133   24
# reset library sizes after filtering
d$samples$lib.size <- colSums(d$counts)
# normalize the data using TMM
d <- calcNormFactors(d, method = "TMM")
plotMDS(d, method="bcv", col=as.numeric(d$samples$group))
legend("bottomleft", as.character(unique(d$samples$group)), col=1:3, pch=20)
# This plot is worth spending more time with.
# Some observations: JNPL3Plus are generally closer together than the Minus (except X370773 and x374367, which are further away)
## FIRST, CLASSIC EDGER ANALYSIS
# Estimate dispersion - first simple way.
d1 <- estimateCommonDisp(d, verbose=T) #assume all same for this pass, GLM later
# Disp = 0.09527 , BCV = 0.3087
d1 <- estimateTagwiseDisp(d1)
plotBCV(d1) #plots the tagwise biological coefficient of variation (square root of dispersions) against log2-CPM.
# observation - looks like a discontinuity in the dispersions around logCPM ~ 7
# Look at DE with exact test
de.tgw <- exactTest(d1)
summary(decideTestsDGE(de.tgw, p.value=0.01))
# Here the entries for -1, 0 and 1 are for down-regulated, non-differentially expressed and up-regulated tags respectively.
#   [,1]
#-1    1
#0  3132
#1     0
design.mat <- model.matrix(~0 + d$samples$group)
colnames(design.mat) <- levels(d$samples$group)
d2 <- estimateGLMCommonDisp(d,design.mat)
d2 <- estimateGLMTrendedDisp(d2,design.mat) #method = "power" also a possibility
# You can change method to "auto", "bin.spline", "power", "spline", "bin.loess".
# The default is "auto" which chooses "bin.spline" when > 200 tags and "power" otherwise.
d2 <- estimateGLMTagwiseDisp(d2, design.mat)
plotBCV(d2) # seems nice - blue line looks like it follows points...
fit <- glmFit(d2, design.mat)
# Andrew used fit <- glmFit(d2, design.mat, dispersion=dge$tagwise.dispersion) but since "If NULL will be extracted from y, with order of precedence: tagwise dispersion, trended dispersions, common dispersion.", I'll leave it out and let it get it from d2.
de_glm  <- glmLRT(fit, contrast=c(-1,1)) # -1*JNPL3Minus 1*JNPL3Plus
#so a positive logFC means transgenic (JNPL3Plus) is higher expression than WT (JNPL3Minus).
summary(decideTestsDGE(de_glm, p.value=0.01))
#[,1]
#-1    1
#0  3132
#1     0
topTags(de_glm)
# Look at DE with glmFit.
#Coefficient:  -1*JNPL3Minus 1*JNPL3Plus
#logFC    logCPM        LR       PValue          FDR
#ENSMUSG00000061808 -5.7919834  7.346404 32.212142 1.382243e-08 4.330566e-05
#ENSMUSG00000042109 -0.9310217  7.857690 17.670991 2.626011e-05 4.113646e-02
#ENSMUSG00000013275  0.4216278  7.707029 15.571870 7.942754e-05 8.294882e-02
#ENSMUSG00000079037  0.7948759 10.942642 13.563288 2.306527e-04 1.806587e-01
#ENSMUSG00000004187 -0.2979300  7.847129 12.543855 3.975113e-04 2.236823e-01
topTen <- rownames(topTags(de_glm, n = 10))
toPlot <- d[topTen] #10 rows, 24 columns
top <- topTags(de_glm, n=50)
# get gene names for x axis labels
ensembl=useMart("ensembl", dataset="mmusculus_gene_ensembl")
geneNames <- getBM(c("ensembl_gene_id", "external_gene_name"),
filters = "ensembl_gene_id",
values = rownames(top)[1:10],
ensembl)
# get label order right for plot
# munge to use with ggplot and plot
toPlot2 <- melt(test)
geom_boxplot(aes(fill = toPlot.samples.group)) +
labels <- geneNames$external_gene_name[(order(match(geneNames$ensembl_gene_id, rownames(top)[1:10])))]
ggplot(toPlot2, aes(factor(variable), value)) +
test  <- data.frame(toPlot$samples$group, t(toPlot$counts))
scale_x_discrete(labels = labels)
test
toPlot2
toPlot
toPlot$samples.group
toPlot$samples$group
ggplot(toPlot2, aes(factor(variable), value)) +
geom_boxplot(aes(fill = toPlot$samples$group)) +
scale_x_discrete(labels = labels)
ggplot(toPlot2, aes(factor(variable), value)) +
geom_boxplot(aes(fill = toPlot.samples.group)) +
scale_x_discrete(labels = labels)
test  <- data.frame(toPlot$samples$group, t(toPlot$counts))
test
toPlot
toPlot2 <- melt(test)
ggplot(toPlot2, aes(factor(variable), value)) +
geom_boxplot(aes(fill = toPlot.samples.group)) +
scale_x_discrete(labels = labels)
labels <- geneNames$external_gene_name[(order(match(geneNames$ensembl_gene_id, rownames(top)[1:10])))]
labels
ggplot(toPlot2, aes(factor(variable), value)) +
geom_boxplot(aes(fill = toPlot.samples.group)) +
scale_x_discrete(labels = labels)
d2 <- estimateGLMTagwiseDisp(d2, design.mat)
plotBCV(d2) # seems nice - blue line looks like it follows points...
q()
